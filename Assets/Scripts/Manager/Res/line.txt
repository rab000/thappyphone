xxxx 1 返回值是否需要做成类
2 处理依赖资源标签的问题
xxxx 3 没使用unload释放的问题
4 扩展resource
xxxx 5 resNode没unload，没回池

单独打包，多资源，依赖资源是否还需要标识，暂时加了标签
理论上通过xml就能得到这个标识信息，这个还需要做个测试
xml不能判断多资源，只能通过加载后的bundle中资源数来判断

资源加载完ResNode，持有这个ResNode或其resID并释放的操作还没有
所有资源需要重新打非压缩的bundle包

resource，streamingAssets 沙盒易用性问题
resource的问题在于需要在端里处理资源，优点在于直观好调整，所以是倾向于开发效率
适合团队开发，对于独立开发，资源全放游戏中，工程体积机会比较大，最好将资源与代码完全独立
ui比较适合放到Resources中

_________________________________________________________________
//总结

xxxx ResInfoFromXml中RuntimeBeDependResStartLoad存在问题，依赖资源理论上可以多次卸载，而这个变量限定依赖只会加载一次
只要去掉这个变量就可以，假设A,B,D都依赖E,当ABC加载时都会加载依赖资源E，E并不会多次加载，因为会判断E是否已经在加载中，是否已经加载完成
如果E在加载中，那么引用次数是否准确的问题

xxxx依赖资源的引用计数从来没增加过
加过了，但是还是要重新过一遍

xxxx引用计数(提前加载asset还是具体使用者用时再加载，提前比较合理)也没建立起来
提前加载，根据资源类型进行加载obj 或objs，但这两个可以永远不使用，只要保证资源
真实加载进来就可以，使用者可以使用Bundle.Load<T>来加载引用资源

xxxx 对象池不够稳固，基本稳固，go和obj走两套池没问题,后续两种对象池都可以单独扩展
现阶段没必要引入池的问题，这个可以单独处理

xxxx获取asset后是否需要持有，释放时自动还是手动
先释放使用者go，然后手动通过ResNode这个资源节点走引用计数

xxxx原始BundleResNode与新ResNode之间关系怎么处理
BundleResNode改为ResLoadingNode只处理加载流程，不用于保存最终得到的Bundle结果
ResNode用于存储最后得到的bundle

xxxx待议:对于使用引用计数的资源，如何避免使用者加载后，立刻释放，引用会归零，然后下次频繁加载同一资源
简单说就是引用计数资源被反复加载卸载，如何避免，毕竟引用计数就是为了避免反复创建卸载
可以用变量设置即使引用为0也不释放，ResNode中可以加特殊标签(手动释放)

xxxx引用计数用于处理哪些资源
依赖，反复使用的，起始引用计数可以用于所有资源，但是引用为0是否释放却不一定
可以不释放或延迟释放，也可以立即释放，这个标签在哪做，这个释放方法由谁决定，是使用者么？
暂定为使用者决定(在最外层接口就加一个卸载类型的参数)

xxxx bytes，unity内置数据存储，图片等资源加载怎么加载，使用统一还是单独一套
没必要单独一套，因为拿到ResNode后，即可以走引用计数，也可以直接彻底销毁

xxxx 貌似引用计数最好用unload(true),一旦unload(false),
除非unloadAll，否则无法清理资源，这个是对的

xxxx tupdate流程作用是否明确
加载优先级(比如依赖加载)，还有同时加载数量要有个缓冲

xxxx 实验下unload(true)是否会有res.unload卸载不干净的问题
能释放干净

xxxx? bundle引用计数可以用bundle.unload(true)来做，而bundle本身
占用内存不大，可以不用卸载，确定不使用了再卸载

xxxx？获取asset后是否需要持有，释放时自动还是手动
看起来结论是使用者要保存资源id，destroy go的同时，要-资源引用

是否要区分ResType，单独，多，依赖，用什么区分
加载得到asset后区分？可以通过加载，或解析时区分，然后在释放时使用
bundle这么做的话resources的资源怎么处理
特别是多资源和依赖
通过资源包装盒处理，包装盒里保存真实资源，并自行处理卸载
原有的粒度大了，方法过多，用第三方static方法处理
